<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>バス位置情報管理</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{ --border:#e5e7eb; --hover:#eff6ff; --brand:#2563eb; --muted:#6b7280; }
  html,body{ height:100%; }
  body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif; margin:0; background:#f9fafb; color:#111827; }
  header{ background:#fff; border-bottom:1px solid var(--border); padding:12px 16px; display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap }
  h1{ margin:0; font-size:1.1rem; }
  .toolbar{ display:flex; gap:6px; flex-wrap:wrap; align-items:center }
  input,button{ padding:6px 10px; border-radius:8px; border:1px solid var(--border); font-size:14px; }
  button{ background:var(--brand); color:#fff; border:none; cursor:pointer; }
  button.ghost{ background:#fff; color:#111827; border:1px solid var(--border) }
  .mini{ font-size:12px; color:#6b7280 }
  .container{ display:grid; grid-template-columns:2fr 1fr; gap:10px; padding:10px; height:calc(100vh - 70px); box-sizing:border-box; }
  .card{ background:#fff; border:1px solid var(--border); border-radius:10px; padding:10px; box-shadow:0 2px 6px rgba(0,0,0,0.05); display:flex; flex-direction:column; }
  #map{ height:100%; width:100%; border-radius:10px; border:1px solid var(--border); }
  table{ width:100%; border-collapse:collapse; }
  th,td{ padding:8px; border-bottom:1px solid #f0f0f0; text-align:left; font-size:14px; }
  th{ color:var(--muted); }
  tr:hover{ background:var(--hover); cursor:pointer; }
  .row-selected{ background:#eef2ff; }
  @media (max-width: 900px){
    .container{ grid-template-columns:1fr; grid-auto-rows:minmax(300px, auto); }
    #map{ height:60vh; }
  }
</style>
</head>
<body>
<header>
  <h1>運行ダッシュボード</h1>
  <div class="toolbar">
    <input id="q" type="search" placeholder="検索: 名前/UID" />
    <input id="date" type="date" />
    <button id="btnShow" class="ghost">選択ドライバーのルート&距離</button>
    <button id="btnSave" class="ghost">この日の結果を履歴保存</button>
    <button id="btnShowAll" class="ghost">全員表示</button>
    <span class="mini" id="distance"></span>
  </div>
</header>

<main class="container">
  <section class="card">
    <div id="map"></div>
  </section>
  <section class="card">
    <div style="overflow:auto; flex:1;">
      <table>
        <thead><tr><th>名前</th><th>UID</th><th>緯度,経度</th><th>更新</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </section>
</main>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore, collection, doc, getDoc, setDoc, query, onSnapshot,
    orderBy, getDocs, where, serverTimestamp, limit
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ==== Firebase 設定（提供値） ====
  const firebaseConfig = {
    apiKey: "AIzaSyC7AK6I_KmkFEZIaWJokO5HN1UnejpHZ3U",
    authDomain: "the-bus-94fe3.firebaseapp.com",
    projectId: "the-bus-94fe3",
    storageBucket: "the-bus-94fe3.firebasestorage.app",
    messagingSenderId: "782387450057",
    appId: "1:782387450057:web:d6d4dcf0fd778ff6533d18",
    measurementId: "G-D9627JEYQ6"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ==== 地図（Leaflet） ====
  let map = L.map('map').setView([35.3942,139.4661], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'© OpenStreetMap'}).addTo(map);
  const markers = new Map();     // uid -> Marker
  let selectedUid = null;
  let routeLayer = null;

  const qInput = document.getElementById('q');
  const dateInput = document.getElementById('date');
  const btnShow = document.getElementById('btnShow');
  const btnSave = document.getElementById('btnSave');
  const btnShowAll = document.getElementById('btnShowAll');
  const distanceEl = document.getElementById('distance');
  const tbody = document.getElementById('tbody');

  // livePositions のキャッシュ
  let liveCache = [];

  // ==== accounts から名前を引く（uid -> displayName）。結果はメモリキャッシュ ====
  const nameCache = new Map();  // uid -> name
  async function resolveName(uid){
    if(nameCache.has(uid)) return nameCache.get(uid);
    // accounts の中で uid フィールドが一致するものを 1件
    const qAcc = query(collection(db, 'accounts'), where('uid','==',uid), limit(1));
    const snap = await getDocs(qAcc);
    const name = snap.empty ? '' : (snap.docs[0].data().name || '');
    nameCache.set(uid, name);
    // 名前が分かったら一覧とポップアップを更新
    updatePopupsFor(uid);
    renderList();
    return name;
  }
  function getDisplayName(uid){
    return nameCache.get(uid) || ''; // 未解決は空文字（あとで resolveName が埋める）
  }

  function ensureMarker(id){
    if(!markers.has(id)){
      const m = L.marker([0,0]); markers.set(id,m);
    }
    return markers.get(id);
  }

  function updatePopupsFor(uid){
    const v = liveCache.find(x=>x.uid===uid);
    if(!v) return;
    const m = markers.get(uid);
    if(!m) return;
    const nm = getDisplayName(uid) || v.email || uid;
    const t = v.updatedAt?.seconds ? new Date(v.updatedAt.seconds*1000).toLocaleString('ja-JP') : '-';
    m.bindPopup(`<strong>${nm}</strong><br>${v.lat.toFixed(6)}, ${v.lng.toFixed(6)}<br>${t}`);
  }

  function setMarker(v){
    const id = v.uid, latlng=[v.lat,v.lng];
    const m = ensureMarker(id);
    m.setLatLng(latlng);
    if(!map.hasLayer(m)) m.addTo(map);

    // 名前を解決してポップアップへ
    const nm = getDisplayName(id) || v.email || id;
    const t = v.updatedAt?.seconds ? new Date(v.updatedAt.seconds*1000).toLocaleString('ja-JP') : '-';
    m.bindPopup(`<strong>${nm}</strong><br>${v.lat.toFixed(6)}, ${v.lng.toFixed(6)}<br>${t}`);

    // 名前未解決なら非同期で取得（取得後に更新）
    if(!nameCache.has(id)) resolveName(id).catch(console.error);
  }

  // 他マーカー非表示（一覧は絞らない）
  function hideOtherMarkers(keepUid){
    markers.forEach((m, id)=>{
      if(id !== keepUid && map.hasLayer(m)) map.removeLayer(m);
      if(id === keepUid && !map.hasLayer(m)) m.addTo(map);
    });
  }
  function showAllMarkers(){
    markers.forEach((m)=>{ if(!map.hasLayer(m)) m.addTo(map); });
  }

  // 一覧の描画（常に全員表示。検索だけ反映）
  function renderList(){
    const q = (qInput.value||'').toLowerCase();
    tbody.innerHTML = '';
    let firstLatLng = null;

    liveCache.forEach(v=>{
      if(!v || v.lat==null || v.lng==null) return;

      const name = (getDisplayName(v.uid) || v.email || '').toLowerCase();
      const text = name + ' ' + (v.uid||'').toLowerCase();
      if(q && !text.includes(q)) return;

      setMarker(v);
      firstLatLng ||= [v.lat, v.lng];

      const tr = document.createElement('tr');
      if(selectedUid === v.uid) tr.classList.add('row-selected');
      tr.onclick = ()=>{
        selectedUid = v.uid;
        hideOtherMarkers(selectedUid);              // ←他マーカーだけ非表示
        map.setView([v.lat,v.lng], Math.max(map.getZoom(),15));
        markers.get(v.uid)?.openPopup();
        // 一覧は絞らない（全員表示のまま）。強調だけ更新。
        renderList();
      };
      const dispName = getDisplayName(v.uid) || v.email || v.uid;
      tr.innerHTML = `
        <td>${dispName}</td>
        <td>${v.uid||''}</td>
        <td>${Number(v.lat).toFixed(6)}, ${Number(v.lng).toFixed(6)}</td>
        <td>${v.updatedAt?.seconds ? new Date(v.updatedAt.seconds*1000).toLocaleTimeString('ja-JP',{hour12:false}) : '-'}</td>
      `;
      tbody.appendChild(tr);
    });

    if(firstLatLng && !selectedUid) map.setView(firstLatLng);
  }

  // livePositions を購読
  const liveCol = collection(db, "livePositions");
  onSnapshot(query(liveCol), (snap)=>{
    liveCache = [];
    snap.forEach(docSnap=>{
      const v = docSnap.data();
      if(v) liveCache.push(v);
    });
    // 名前の事前解決（新規uidのみ）
    liveCache.forEach(v => { if(!nameCache.has(v.uid)) resolveName(v.uid).catch(console.error); });

    // マーカーの可視制御
    if(selectedUid){ hideOtherMarkers(selectedUid); }
    renderList();
  });

  qInput.addEventListener('input', renderList);

  // ==== 距離計算・ルート描画・保存 ====
  const R=6371000, toRad=d=>d*Math.PI/180;
  function haversine(a,b){
    const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
    const s=Math.sin(dLat/2)**2+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dLng/2)**2;
    return 2*R*Math.asin(Math.sqrt(s));
  }
  function rdp(points, epsilonMeters=20){
    if(points.length<=2) return points;
    const epsilonRad = epsilonMeters / R;
    const toXY = (p)=>({x: toRad(p.lng)*Math.cos(toRad(p.lat)), y: toRad(p.lat)});
    const A = toXY(points[0]), B = toXY(points[points.length-1]);
    let idx=-1, dmax=0;
    for(let i=1;i<points.length-1;i++){
      const P=toXY(points[i]);
      const num = Math.abs((B.y-A.y)*P.x - (B.x-A.x)*P.y + B.x*A.y - B.y*A.x);
      const den = Math.hypot(B.y-A.y, B.x-A.x) || 1e-9;
      const d = num/den;
      if(d>dmax){ dmax=d; idx=i; }
    }
    if(dmax>epsilonRad){
      const left = rdp(points.slice(0, idx+1), epsilonMeters);
      const right = rdp(points.slice(idx), epsilonMeters);
      return left.slice(0,-1).concat(right);
    }else{
      return [points[0], points[points.length-1]];
    }
  }
  function drawRoute(points){
    if(routeLayer){ routeLayer.remove(); routeLayer=null; }
    if(points.length>=2){
      routeLayer = L.polyline(points.map(p=>[p.lat,p.lng]), {weight:4}).addTo(map);
      map.fitBounds(routeLayer.getBounds(), {padding:[20,20]});
    }
  }

  async function loadOrCompute(uid, dateStr){
    const dRef = doc(db, "drivers", uid, "daily", dateStr);
    const saved = await getDoc(dRef);
    if(saved.exists()){
      const data = saved.data();
      const coords = data?.line?.coordinates || [];
      const pts = coords.map(([lng,lat])=>({lat,lng}));
      drawRoute(pts);
      distanceEl.textContent = typeof data?.distanceMeters==='number'
        ? `選択日距離: ${(data.distanceMeters/1000).toFixed(2)} km（保存済）`
        : `選択日距離: - （保存済）`;
      return { points: pts, distanceM: data?.distanceMeters||0, saved:true };
    }

    const from = new Date(`${dateStr}T00:00:00+09:00`);
    const to   = new Date(`${dateStr}T23:59:59.999+09:00`);
    const posCol = collection(db, "drivers", uid, "positions");
    const q1 = query(posCol, where('serverAt','>=', from), where('serverAt','<=', to), orderBy('serverAt','asc'));
    const snap = await getDocs(q1);

    const pts = [];
    snap.forEach(d=>{
      const x = d.data();
      if(typeof x.lat==='number' && typeof x.lng==='number'){
        if(x.accuracy==null || x.accuracy<=80) pts.push({lat:x.lat, lng:x.lng});
      }
    });

    let distM = 0;
    for(let i=1;i<pts.length;i++) distM += haversine(pts[i-1],pts[i]);

    const simp = rdp(pts, 20);
    drawRoute(simp);
    distanceEl.textContent = `選択日距離: ${(distM/1000).toFixed(2)} km（推定/未保存）`;
    return { points: simp, distanceM: Math.round(distM), saved:false };
  }

  btnShow.onclick = async ()=>{
    if(!selectedUid){ alert('一覧からドライバーを選択してください'); return; }
    const dateStr = dateInput.value;
    if(!dateStr){ alert('日付を選択してください'); return; }
    await loadOrCompute(selectedUid, dateStr);
  };

  btnSave.onclick = async ()=>{
    if(!selectedUid){ alert('一覧からドライバーを選択してください'); return; }
    const dateStr = dateInput.value;
    if(!dateStr){ alert('日付を選択してください'); return; }
    const { points, distanceM } = await loadOrCompute(selectedUid, dateStr);
    if(points.length < 2){ alert('この日はデータが足りません'); return; }
    const line = { type:"LineString", coordinates: points.map(p=>[p.lng,p.lat]) };
    await setDoc(doc(db, "drivers", selectedUid, "daily", dateStr), {
      uid: selectedUid, date: dateStr, distanceMeters: distanceM, line,
      updatedAt: serverTimestamp()
    }, { merge:true });
    distanceEl.textContent = `選択日距離: ${(distanceM/1000).toFixed(2)} km（保存済）`;
    alert('保存しました');
  };

  btnShowAll.onclick = ()=>{
    selectedUid = null;
    showAllMarkers();    // 地図に全マーカー再表示
    renderList();        // 一覧は元々全員表示なので強調だけ解除
    if(routeLayer){ routeLayer.remove(); routeLayer=null; }
    distanceEl.textContent = '';
  };
</script>
</body>
</html>
